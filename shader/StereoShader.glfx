////GLOBAL
#version 330

////DEFINES
#include "Helpers.fxh"

uniform float4 ms_zpd_ya_td;
uniform float4 w_h_height; // for bloom, w_h_height.z keeps strength; for dither, w_h_height.zw keeps per-frame offset for temporal variation of the pattern

uniform float2 Anaglyph_DeSaturation_Brightness; // Anaglyph (de)saturation to preprocess/remove color from the anaglyph image: 1 = Black & White, 0 = normal color


float3 anaglyph(const float3 L, const float3 R)
{
	// Convert to linear RGB, perform desaturation, and adjust brightness
	// Theorically we should double brightness since the image's color space is splitted in 2 and each eye should only receive half 
	// of the brightness it would receive without anaglyph. In practice, this highly depends on the user glasses since the filters
	// are not perfectly fitted to the rendering (an eye can receive light targeted at the other eye) and glasses are not fully
	// transparent causing some light losses.
	const float3 Llin = InvGamma(L);
	const float3 Rlin = InvGamma(R);
	const float brightness = Anaglyph_DeSaturation_Brightness.y;
	const float3 LMAlin = brightness * lerp(Llin, float3(Luminance(Llin)), Anaglyph_DeSaturation_Brightness.x);
	const float3 RMAlin = brightness * lerp(Rlin, float3(Luminance(Rlin)), Anaglyph_DeSaturation_Brightness.x);

	BRANCH if (ms_zpd_ya_td.w == 5.0 || ms_zpd_ya_td.w == 12.0) // Anaglyph 3D Red/Cyan
	{
		return FBGamma(float3(LMAlin.r, RMAlin.g, RMAlin.b));
	}
	BRANCH if (ms_zpd_ya_td.w == 6.0 || ms_zpd_ya_td.w == 13.0) // Anaglyph 3D Green/Magenta
	{
		return FBGamma(float3(RMAlin.r, LMAlin.g, RMAlin.b));
	}
	BRANCH if (ms_zpd_ya_td.w == 7.0 || ms_zpd_ya_td.w == 14.0) // Anaglyph 3D Dubois Red/Cyan
	{
		// Dubois matrices are given in sRGB space
		const float3 LMA = FBGamma(LMAlin);
		const float3 RMA = FBGamma(RMAlin);
		const float r = dot(LMA, float3( 0.437,  0.449,  0.164)) + dot(RMA, float3(-0.011, -0.032, -0.007));
		const float g = dot(LMA, float3(-0.062, -0.062, -0.024)) + dot(RMA, float3( 0.377,  0.761,  0.009));
		const float b = dot(LMA, float3(-0.048, -0.050, -0.017)) + dot(RMA, float3(-0.026, -0.093,  1.234));
		return saturate(float3(r,g,b));
	}
	BRANCH if (ms_zpd_ya_td.w == 8.0 || ms_zpd_ya_td.w == 15.0) // Anaglyph 3D Dubois Green/Magenta
	{
		// Dubois matrices are given in sRGB space
		const float3 LMA = FBGamma(LMAlin);
		const float3 RMA = FBGamma(RMAlin);
		const float r = dot(LMA, float3(-0.062, -0.158, -0.039)) + dot(RMA, float3( 0.529,  0.705, 0.024));
		const float g = dot(LMA, float3( 0.284,  0.668,  0.143)) + dot(RMA, float3(-0.016, -0.015, 0.065));
		const float b = dot(LMA, float3(-0.015, -0.027,  0.021)) + dot(RMA, float3( 0.009,  0.075, 0.937));
		return saturate(float3(r,g,b));
	}
	BRANCH if (ms_zpd_ya_td.w == 9.0 || ms_zpd_ya_td.w == 16.0) // Anaglyph 3D Deghosted Red/Cyan
	{
		// Code From http://iaian7.com/quartz/AnaglyphCompositing & vectorform.com by John Einselen
		// Based on an Apple Quartz filter which is applied in linear color space (not 100% sure, but checked with online resources)
		const float DeGhost = 0.06 * 0.1;
		const float c = 1.0; // saturate(Anaglyph_DeSaturation_Brightness.y*0.5 + 0.5);
		const float LOne = c*0.45;
		const float ROne = c;
		
		// Left eye
		float3 accum = saturate(LMAlin * float3(LOne, (1.0-LOne)*0.5, (1.0-LOne)*0.5));
		const float r = /*pow(*/accum.r+accum.g+accum.b/*, 1.00)*/;
		
		// Right eye
			   accum = saturate(RMAlin * float3(1.0-ROne, ROne, ROne));
		const float g = pow(accum.r+accum.g, 1.15);
		const float b = pow(accum.r+accum.b, 1.15);
		
		// Composition
		float3 color;
		color.r = r + r* DeGhost        + g*(DeGhost* -0.5) + b*(DeGhost*-0.5);
		color.g = g + r*(DeGhost*-0.25) + g*(DeGhost*  0.5) + b*(DeGhost*-0.25);
		color.b = b + r*(DeGhost*-0.25) + g*(DeGhost*-0.25) + b*(DeGhost* 0.5);
		return saturate(FBGamma(color));
	}
	BRANCH if (ms_zpd_ya_td.w == 10.0 || ms_zpd_ya_td.w == 17.0) // Anaglyph 3D Deghosted Green/Magenta
	{
		// Code From http://iaian7.com/quartz/AnaglyphCompositing & vectorform.com by John Einselen
		// Based on an Apple Quartz filter which is applied in linear color space (not 100% sure, but checked with online resources)
		const float DeGhost = 0.06 * 0.275;
		const float c = 1.0; // saturate(Anaglyph_DeSaturation_Brightness.y*0.5 + 0.5);
		const float LOne = c*0.45;
		const float ROne = c*0.8;
		
		// Left eye
		float3 accum = saturate(RMAlin * float3(ROne, 1.0-ROne, ROne));
		const float r = pow(accum.r+accum.g, 1.15);
		const float b = pow(accum.g+accum.b, 1.15);
		
		// Right eye
			   accum = saturate(LMAlin * float3((1.0-LOne)*0.5, LOne, (1.0-LOne)*0.5));
		const float g = pow(accum.r+accum.g+accum.b, 1.05);
		
		// Composition
		float3 color;
		color.r = r + r*(DeGhost* 0.5)  + g*(DeGhost*-0.25) + b*(DeGhost*-0.25);
		color.g = g + r*(DeGhost*-0.5)  + g*(DeGhost* 0.25) + b*(DeGhost*-0.5);
		color.b = b + r*(DeGhost*-0.25) + g*(DeGhost*-0.25) + b*(DeGhost*0.5);
		return saturate(FBGamma(color));
	}
	BRANCH if (ms_zpd_ya_td.w == 11.0 || ms_zpd_ya_td.w == 18.0) // Anaglyph 3D Blue/Amber
	{
		// Code From http://iaian7.com/quartz/AnaglyphCompositing & vectorform.com by John Einselen
		// Based on an Apple Quartz filter which is applied in linear color space (not 100% sure, but checked with online resources)
		const float DeGhost = 0.06 * 0.275;
		const float c = 1.0; // saturate(Anaglyph_DeSaturation_Brightness.y*0.5 + 0.5);
		const float LOne = c*0.45;
		const float ROne = c;
		
		// Left eye
		float3 accum = saturate(LMAlin * float3(ROne, ROne, 1.0-ROne));
		const float r = pow(accum.r+accum.b, 1.05);
		const float g = pow(accum.g+accum.b, 1.10);
		
		// Right eye
			   accum = saturate(RMAlin * float3((1.0-LOne)*0.5, (1.0-LOne)*0.5, LOne));
		float b = /*pow(*/accum.r+accum.g+accum.b/*, 1.0)*/;
			  b = lerp(pow(b,(DeGhost*0.15)+1.0), 1.0-pow(abs(1.0-b),(DeGhost*0.15)+1.0), b);
			  
		// Composition
		float3 color;
		color.r = r + r*(DeGhost*  1.5) + g*(DeGhost*-0.75) + b*(DeGhost*-0.75);
		color.g = g + r*(DeGhost*-0.75) + g*(DeGhost*  1.5) + b*(DeGhost*-0.75);
		color.b = b + r*(DeGhost* -1.5) + g*(DeGhost* -1.5) + b*(DeGhost*3.0);
		return saturate(FBGamma(color));
	}
	return FBGamma(0.5 * LMAlin / brightness); //!! testing mode
}

////VERTEX

layout(location=0) in vec3 vPosition;
layout(location=1) in vec2 tc;

out vec2 tex0;

////FRAGMENT

uniform sampler2DArray  tex_stereo_fb; // Render buffer with the 2 eyes

in vec2 tex0;

out vec4 color;

////vs_main_no_trafo

void main()
{
   gl_Position = vec4(vPosition.x, vPosition.y, 0.0, 1.0);
   tex0 = float2(tc.x, 1.0-tc.y);
}

////ps_main_tb

void main()
{
   color = textureLod(tex_stereo_fb, vec3(tex0.x, tex0.y * 2.0, tex0.y < 0.5 ? 0.0 : 1.0), 0.);
}

////ps_main_sbs

void main()
{
   color = textureLod(tex_stereo_fb, vec3(tex0.x * 2.0, tex0.y, tex0.x < 0.5 ? 0.0 : 1.0), 0.);
}

////ps_main_int

void main()
{
   // FIXME this cause an unwanted filtering
   color = textureLod(tex_stereo_fb, vec3(tex0.x, tex0.y, frac(gl_FragCoord.y*0.5) < 0.5 ? 0.0 : 1.0), 0.);
}

////ps_main_flipped_int

void main()
{
   // FIXME this cause an unwanted filtering
   color = textureLod(tex_stereo_fb, vec3(tex0.x, tex0.y, frac(gl_FragCoord.y*0.5) < 0.5 ? 1.0 : 0.0), 0.);
}

////ps_main_stereo_anaglyph

void main()
{
	const float3 lcol = textureLod(tex_stereo_fb, vec3(tex0.x, tex0.y, 0.), 0.).xyz;
	const float3 rcol = textureLod(tex_stereo_fb, vec3(tex0.x, tex0.y, 1.), 0.).xyz;
	const float3 l = (ms_zpd_ya_td.w > 11.0) ? rcol : lcol; // > 11.0 means: flip the eye color
	const float3 r = (ms_zpd_ya_td.w > 11.0) ? lcol : rcol; // > 11.0 means: flip the eye color
	color = float4(anaglyph(l, r), 1.0);
}


////TECHNIQUES

stereo_SBS:P0:vs_main_no_trafo():ps_main_sbs()
stereo_TB:P0:vs_main_no_trafo():ps_main_tb()
stereo_Int:P0:vs_main_no_trafo():ps_main_int()
stereo_Flipped_Int:P0:vs_main_no_trafo():ps_main_flipped_int()
stereo_anaglyph:P0:vs_main_no_trafo():ps_main_stereo_anaglyph()
