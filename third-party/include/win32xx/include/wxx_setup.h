// Win32++   Version 10.0.0
// Release Date: 9th September 2024
//
//      David Nash
//      email: dnash@bigpond.net.au
//      url: https://sourceforge.net/projects/win32-framework
//           https://github.com/DavidNash2024/Win32xx
//
//
// Copyright (c) 2005-2024  David Nash
//
// Permission is hereby granted, free of charge, to
// any person obtaining a copy of this software and
// associated documentation files (the "Software"),
// to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify,
// merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom
// the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice
// shall be included in all copies or substantial portions
// of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
// ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
// SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
// ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
// OR OTHER DEALINGS IN THE SOFTWARE.
//
////////////////////////////////////////////////////////


////////////////////////////////////////////////////////
// This file defines the set of version macros for windows
// and includes the header files required by Win32++. It
// also contains many of the global functions used by
// Win32++.


#ifndef _WIN32XX_SETUP_H_
#define _WIN32XX_SETUP_H_

// Set the windows version macros. These must be defined before including windows.h.
// These values are suitable for Windows 10 and Windows 11.
#define WINVER            0x0A00
#undef  _WIN32_WINNT
#define _WIN32_WINNT      0x0A00
#undef  _WIN32_IE
#define _WIN32_IE         0x0A00
#undef  NTDDI_VERSION
#define NTDDI_VERSION     0x0A000000

#ifndef NOMINMAX
#define NOMINMAX        // Allow std::min and std::max. Must be defined before including windows.h.
#endif

// Support the Winsock functions required for Windows XP.
#define _WINSOCK_DEPRECATED_NO_WARNINGS

#include <WinSock2.h>   // Must include before windows.h.
#include <Windows.h>
#include <Shlwapi.h>

#if defined (_MSC_VER)
#pragma warning( push )
#pragma warning( disable : 4091 )  // Hide warning generated by shlobj.h in VS2015.
#endif
#include <shlobj.h>
#if defined (_MSC_VER)
#pragma warning( pop )
#endif

#include <cassert>
#include <vector>
#include <algorithm>
#include <memory>
#include <string>
#include <map>
#include <sstream>
#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>
#include <process.h>

// Automatically include the Win32xx namespace.
// define NO_USING_NAMESPACE to skip this step.
namespace Win32xx {}
#ifndef NO_USING_NAMESPACE
using namespace Win32xx;
#endif


// Ensure UNICODE and _UNICODE definitions are consistent.
#ifdef _UNICODE
  #ifndef UNICODE
    #define UNICODE
  #endif
#endif

#ifdef UNICODE
  #ifndef _UNICODE
    #define _UNICODE
  #endif
#endif

// Define our own MIN and MAX macros.
// This avoids inconsistencies with MinGW and other compilers, and
// avoids conflicts between typical min/max macros and std::min/std::max
// Warning: These macros are now deprecated. Use std::min and std::max instead.
#define MAX(a,b)        (((a) > (b)) ? (a) : (b))
#define MIN(a,b)        (((a) < (b)) ? (a) : (b))

// Version macro
#define _WIN32XX_VER 0x1000     // Win32++ version 10.0.0

// Define the TRACE Macro.
// In debug mode, TRACE send text to the debug/output pane, or an external debugger
// In release mode, TRACE is ignored.
#ifndef TRACE
  #ifdef NDEBUG
    #define TRACE(str) (void(0))
  #else
    #define TRACE(str) Trace(str)
  #endif
#endif

// Define the VERIFY macro
// In debug mode, VERIFY asserts if the expression evaluates to zero.
// In release mode, VERIFY evaluates the expression, but doesn't assert.
#ifndef VERIFY
  #ifdef NDEBUG
    #define VERIFY(f) ((void)(f))
  #else
    #define VERIFY(f) assert(f)
  #endif
#endif

// Define useful macros from windowsx.h.
#ifndef GET_X_LPARAM
  #define GET_X_LPARAM(lp)  ((int)(short)LOWORD(lp))
#endif
#ifndef GET_Y_LPARAM
  #define GET_Y_LPARAM(lp)  ((int)(short)HIWORD(lp))
#endif

namespace Win32xx
{
    // tString is a TCHAR std::string.
    // tStringStream is a TCHAR std::stringstream.
    using tString = std::basic_string<TCHAR>;
    using tStringStream = std::basic_stringstream<TCHAR>;

    ////////////////////////////////////////
    // Global Functions
    //

    // Retrieves the version of common control dll used.
    // return values and DLL versions
    // 400  dll ver 4.00    Windows 95/Windows NT 4.0
    // 470  dll ver 4.70    Internet Explorer 3.x
    // 471  dll ver 4.71    Internet Explorer 4.0
    // 472  dll ver 4.72    Internet Explorer 4.01 and Windows 98
    // 580  dll ver 5.80    Internet Explorer 5
    // 581  dll ver 5.81    Windows 2000 and Windows ME
    // 582  dll ver 5.82    Windows XP, Vista, Windows 7 etc. without XP themes
    // 600  dll ver 6.00    Windows XP with XP themes
    // 610  dll ver 6.10    Windows Vista with XP themes
    // 616  dll ver 6.16    Windows Vista SP1 or above with XP themes
    inline int GetComCtlVersion()
    {
#ifndef NDEBUG
        OutputDebugString(_T("*** Warning: GetComCtlVersion is deprecated. ***\n"));
#endif

        // Retrieve the Common Controls DLL handle.
        HMODULE comCtl = ::GetModuleHandle(_T("comctl32.dll"));
        if (comCtl == nullptr)
            return 0;

        DWORD comCtlVer = 600;

        if (::GetProcAddress(comCtl, "DllGetVersion"))
        {
            DLLGETVERSIONPROC pfnDLLGetVersion;

            pfnDLLGetVersion = reinterpret_cast<DLLGETVERSIONPROC>(
                reinterpret_cast<void*>(::GetProcAddress(comCtl, "DllGetVersion")));
            if (pfnDLLGetVersion)
            {
                DLLVERSIONINFO dvi;
                ZeroMemory(&dvi, sizeof(dvi));
                dvi.cbSize = sizeof dvi;
                if (NOERROR == pfnDLLGetVersion(&dvi))
                {
                    DWORD verMajor = dvi.dwMajorVersion;
                    DWORD verMinor = dvi.dwMinorVersion;
                    comCtlVer = 100 * verMajor + verMinor;
                }
            }
        }

        return static_cast<int>(comCtlVer);
    }

    // Retrieves the window version
    // Return values and window versions:
    //  1400     Windows 95
    //  1410     Windows 98
    //  1490     Windows ME
    //  2400     Windows NT
    //  2500     Windows 2000
    //  2501     Windows XP
    //  2502     Windows Server 2003
    //  2600     Windows Vista and Windows Server 2008
    //  2601     Windows 7 and Windows Server 2008 r2
    //  2602     Windows 8 and Windows Server 2012
    //  2603     Windows 8.1 and Windows Server 2012 r2
    //  3000     Windows 10 or Windows 11
    inline int GetWinVersion()
    {
        // Declare a pointer to the RtlGetVersion function.
        using RTLGETVERSION = void (WINAPI*)(PRTL_OSVERSIONINFOW);

        HMODULE module = ::GetModuleHandleW(L"ntdll.dll");
        RTL_OSVERSIONINFOW osvi{};
        if (module)
        {
            RTLGETVERSION pfn = reinterpret_cast<RTLGETVERSION>(
                reinterpret_cast<void*>(::GetProcAddress(module, "RtlGetVersion")));

            if (pfn != nullptr)
            {
                osvi.dwOSVersionInfoSize = sizeof(osvi);
                pfn(&osvi);
            }
        }

        DWORD platform = osvi.dwPlatformId;
        DWORD majorVer = osvi.dwMajorVersion;
        DWORD minorVer = osvi.dwMinorVersion;

        DWORD result = 1000 * platform + 100 * majorVer + minorVer;
        return static_cast<int>(result);
    }

    // Returns a NONCLIENTMETRICS struct filled from the system parameters.
    // Refer to NONCLIENTMETRICS in the Windows API documentation for more information.
    inline NONCLIENTMETRICS GetNonClientMetrics()
    {
        NONCLIENTMETRICS ncm{};
        ncm.cbSize = sizeof(ncm);

        // If OS version less than Vista, adjust size to correct value.
        if (GetWinVersion() < 2600)
            ncm.cbSize = CCSIZEOF_STRUCT(NONCLIENTMETRICS, lfMessageFont);

        VERIFY(::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0));

        return ncm;
    }

    // Reports the state of the left mouse button.
    // Refer to GetAsyncKeyState in the Windows API documentation for more information.
    inline BOOL IsLeftButtonDown()
    {
        SHORT state;
        if (::GetSystemMetrics(SM_SWAPBUTTON))
            // Mouse buttons are swapped.
            state = ::GetAsyncKeyState(VK_RBUTTON);
        else
            // Mouse buttons are not swapped.
            state = ::GetAsyncKeyState(VK_LBUTTON);

        // Returns true if the left mouse button is down.
        return (state & 0x8000);
    }

    // Loads the common controls using InitCommonControlsEx.
    // Refer to InitCommonControlsEx in the Windows API documentation for more information.
    inline void LoadCommonControls()
    {
          // Load the full set of common controls.
          INITCOMMONCONTROLSEX initStruct{};
          initStruct.dwSize = sizeof(initStruct);
          initStruct.dwICC = ICC_WIN95_CLASSES | ICC_BAR_CLASSES | ICC_COOL_CLASSES | ICC_DATE_CLASSES;
          initStruct.dwICC |= ICC_INTERNET_CLASSES | ICC_NATIVEFNTCTL_CLASS | ICC_PAGESCROLLER_CLASS | ICC_USEREX_CLASSES;

          // Call InitCommonControlsEx.
          VERIFY(InitCommonControlsEx(&initStruct));
    }

    // The following functions perform string copies. The size of the dst buffer
    // is specified, much like strcpy_s. The dst buffer is always null terminated.
    // Null or zero arguments cause an assert.

    // Copies an ANSI string from src to dst.
    inline void StrCopyA(char* dst, const char* src, size_t dst_size)
    {
        assert(dst != nullptr);
        assert(src != nullptr);
        assert(dst_size != 0);

        if (dst && src && dst_size != 0)
        {
            size_t index;

            // Copy each character.
            for (index = 0; index < dst_size - 1; ++index)
            {
                dst[index] = src[index];
                if (src[index] == '\0')
                    break;
            }

            // Add null termination if required.
            if (dst[index] != '\0')
                dst[dst_size - 1] = '\0';
        }
    }

    // Copies a wide string from src to dst.
    inline void StrCopyW(wchar_t* dst, const wchar_t* src, size_t dst_size)
    {
        assert(dst != nullptr);
        assert(src != nullptr);
        assert(dst_size != 0);

        if (dst && src && dst_size != 0)
        {
            size_t index;

            // Copy each character.
            for (index = 0; index < dst_size - 1; ++index)
            {
                dst[index] = src[index];
                if (src[index] == L'\0')
                    break;
            }

            // Add null termination if required.
            if (dst[index] != L'\0')
                dst[dst_size - 1] = L'\0';
        }
    }

    // Copies a TCHAR string from src to dst.
    inline void StrCopy(TCHAR* dst, const TCHAR* src, size_t dst_size)
    {
#ifdef UNICODE
        StrCopyW(dst, src, dst_size);
#else
        StrCopyA(dst, src, dst_size);
#endif
    }

}

#endif // _WIN32XX_SETUP_H_
