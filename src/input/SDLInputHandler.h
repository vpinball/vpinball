#pragma once

#include <filesystem>

#include "InputManager.h"

class SDLInputHandler final : public InputManager::InputHandler
{
public:
   explicit SDLInputHandler(InputManager& pininput)
      : m_pininput(pininput)
   {
      PLOGI << "SDL input handler registered";
      if (!SDL_InitSubSystem(SDL_INIT_HAPTIC | SDL_INIT_JOYSTICK | SDL_INIT_GAMEPAD))
      {
         PLOGE << "Failed to initialize joystick and haptic input with error: " << SDL_GetError();
      }

      // These events are generated by the subsystem initialization (this work as long as the SDL subsystem lifecycle follows the SDLInputHandler lifecycle)
      int joystickCount = 0;
      SDL_JoystickID* const joystickIds = SDL_GetJoysticks(&joystickCount);
      for (int i = 0; i < joystickCount; i++)
         OnJoystickAdded(joystickIds[i]);
   }

   SDLInputHandler& operator=(SDLInputHandler&&) = delete;

   ~SDLInputHandler() override
   {
      for (const auto& joy : m_joysticks)
         OnJoystickRemoved(SDL_GetJoystickID(joy.joystick));
      SDL_QuitSubSystem(SDL_INIT_HAPTIC | SDL_INIT_JOYSTICK | SDL_INIT_GAMEPAD);
   }

   void PlayRumble(const float lowFrequencySpeed, const float highFrequencySpeed, const int ms_duration) override
   {
      for (const auto& joy : m_joysticks)
         if (joy.haptic)
            SDL_PlayHapticRumble(joy.haptic, saturate(max(lowFrequencySpeed, highFrequencySpeed)), ms_duration); //!! meh
   }

   void Update() override
   {
      if (!SDL_JoystickEventsEnabled())
         SDL_UpdateJoysticks();
   }

   void HandleSDLEvent(const SDL_Event& e)
   {
      switch (e.type)
      {
      case SDL_EVENT_KEY_DOWN:
      case SDL_EVENT_KEY_UP:
         if (e.key.repeat == 0)
            m_pininput.PushButtonEvent(m_pininput.GetKeyboardDeviceId(), static_cast<uint16_t>(e.key.scancode), e.key.timestamp, e.key.down);
         break;

      case SDL_EVENT_MOUSE_BUTTON_DOWN:
      case SDL_EVENT_MOUSE_BUTTON_UP:
         if (e.button.which != SDL_TOUCH_MOUSEID && e.button.which != SDL_PEN_MOUSEID)
            m_pininput.PushButtonEvent(m_pininput.GetMouseDeviceId(), e.button.button, e.button.timestamp, e.button.down);
         break;

      case SDL_EVENT_JOYSTICK_ADDED: OnJoystickAdded(e.jdevice.which); break;

      case SDL_EVENT_JOYSTICK_REMOVED: OnJoystickRemoved(e.jdevice.which); break;

      case SDL_EVENT_JOYSTICK_BUTTON_DOWN:
      case SDL_EVENT_JOYSTICK_BUTTON_UP: m_pininput.PushButtonEvent(m_joystickIds[e.jbutton.which], e.jbutton.button, e.jbutton.timestamp, e.jbutton.down); break;

      case SDL_EVENT_JOYSTICK_HAT_MOTION:
      {
         const uint16_t hatId = e.jhat.hat * 4;
         m_pininput.PushButtonEvent(m_joystickIds[e.jhat.which], 0x0100 | hatId, e.jhat.timestamp, (e.jhat.value & SDL_HAT_LEFT) != 0);
         m_pininput.PushButtonEvent(m_joystickIds[e.jhat.which], 0x0101 | hatId, e.jhat.timestamp, (e.jhat.value & SDL_HAT_RIGHT) != 0);
         m_pininput.PushButtonEvent(m_joystickIds[e.jhat.which], 0x0102 | hatId, e.jhat.timestamp, (e.jhat.value & SDL_HAT_UP) != 0);
         m_pininput.PushButtonEvent(m_joystickIds[e.jhat.which], 0x0103 | hatId, e.jhat.timestamp, (e.jhat.value & SDL_HAT_DOWN) != 0);
         break;
      }

      case SDL_EVENT_JOYSTICK_AXIS_MOTION: m_pininput.PushAxisEvent(m_joystickIds[e.jaxis.which], 0x0200 | e.jaxis.axis, e.jaxis.timestamp, static_cast<float>(e.jaxis.value) / 32768.f); break;

      case SDL_EVENT_FINGER_DOWN:
      case SDL_EVENT_FINGER_UP:
         if (e.tfinger.windowID == SDL_GetWindowID(g_pplayer->m_playfieldWnd->GetCore()))
            m_pininput.PushTouchEvent(e.tfinger.x, e.tfinger.y, e.tfinger.timestamp, e.type == SDL_EVENT_FINGER_DOWN);
         break;

      default: break;
      }
   }

private:
   static string GetJoySettingId(SDL_Joystick* joy)
   {
      if (const char* serial = SDL_GetJoystickSerial(joy); serial)
         return "SDLJoy_"s + serial;
      SDL_GUID guid = SDL_GetJoystickGUID(joy); // Stable class of the device. Always available but not unique to a single device.
      uint16_t vendor, product, version, crc16;
      SDL_GetJoystickGUIDInfo(guid, &vendor, &product, &version, &crc16);
      PLOGD << "Joystick '" << SDL_GetJoystickName(joy) << "' does not provide a serial number but a generic GUID. This may eventually results in input conflicts.";
      char strGuid[33];
      SDL_GUIDToString(guid, strGuid, 33);
      return "SDLJoy_"s + strGuid;
   }

   static string GetGamepadButtonName(SDL_Gamepad* gamepad, SDL_GamepadButton button)
   {
      switch (SDL_GetGamepadButtonLabel(gamepad, button))
      {
      case SDL_GAMEPAD_BUTTON_LABEL_A: return "A"s;
      case SDL_GAMEPAD_BUTTON_LABEL_B: return "B"s;
      case SDL_GAMEPAD_BUTTON_LABEL_X: return "X"s;
      case SDL_GAMEPAD_BUTTON_LABEL_Y: return "Y"s;
      case SDL_GAMEPAD_BUTTON_LABEL_CROSS: return "Cross"s; // ICON_FK_TIMES
      case SDL_GAMEPAD_BUTTON_LABEL_CIRCLE: return "Circle"s; // ICON_FK_CIRCLE_O
      case SDL_GAMEPAD_BUTTON_LABEL_SQUARE: return "Square"s; // ICON_FK_SQUARE_O
      case SDL_GAMEPAD_BUTTON_LABEL_TRIANGLE: return "Triangle"s; // Sadly, nothing for triangle
      default:
         switch (button)
         {
         case SDL_GAMEPAD_BUTTON_SOUTH: return "South"s;
         case SDL_GAMEPAD_BUTTON_EAST: return "East"s;
         case SDL_GAMEPAD_BUTTON_WEST: return "West"s;
         case SDL_GAMEPAD_BUTTON_NORTH: return "North"s;
         case SDL_GAMEPAD_BUTTON_BACK: return "Back"s;
         case SDL_GAMEPAD_BUTTON_GUIDE: return "Guide"s;
         case SDL_GAMEPAD_BUTTON_START: return "Start"s;
         case SDL_GAMEPAD_BUTTON_LEFT_STICK: return "Left Stick"s;
         case SDL_GAMEPAD_BUTTON_RIGHT_STICK: return "Right Stick"s;
         case SDL_GAMEPAD_BUTTON_LEFT_SHOULDER: return "Left Shoulder"s;
         case SDL_GAMEPAD_BUTTON_RIGHT_SHOULDER: return "Right Shoulder"s;
         case SDL_GAMEPAD_BUTTON_DPAD_UP: return "DPad Up"s;
         case SDL_GAMEPAD_BUTTON_DPAD_DOWN: return "DPad Down"s;
         case SDL_GAMEPAD_BUTTON_DPAD_LEFT: return "DPad Left"s;
         case SDL_GAMEPAD_BUTTON_DPAD_RIGHT: return "DPad Right"s;
         case SDL_GAMEPAD_BUTTON_MISC1: return "Misc #1"s;
         case SDL_GAMEPAD_BUTTON_RIGHT_PADDLE1: return "Right Paddle 1"s;
         case SDL_GAMEPAD_BUTTON_LEFT_PADDLE1: return "Left Paddle 1"s;
         case SDL_GAMEPAD_BUTTON_RIGHT_PADDLE2: return "Right Paddle 2"s;
         case SDL_GAMEPAD_BUTTON_LEFT_PADDLE2: return "Left Paddle 2"s;
         case SDL_GAMEPAD_BUTTON_TOUCHPAD: return "Touchpad"s;
         case SDL_GAMEPAD_BUTTON_MISC2: return "Misc #2"s;
         case SDL_GAMEPAD_BUTTON_MISC3: return "Misc #3"s;
         case SDL_GAMEPAD_BUTTON_MISC4: return "Misc #4"s;
         case SDL_GAMEPAD_BUTTON_MISC5: return "Misc #5"s;
         case SDL_GAMEPAD_BUTTON_MISC6: return "Misc #6"s;
         }
         break;
      }
      return ""s;
   }

   static string GetGamepadAxisName(SDL_Gamepad* gamepad, SDL_GamepadAxis axis)
   {
      switch (axis)
      {
      case SDL_GAMEPAD_AXIS_LEFTX: return "Left Stick X"s;
      case SDL_GAMEPAD_AXIS_LEFTY: return "Left Stick Y"s;
      case SDL_GAMEPAD_AXIS_RIGHTX: return "Right Stick X"s;
      case SDL_GAMEPAD_AXIS_RIGHTY: return "Right Stick Y"s;
      case SDL_GAMEPAD_AXIS_LEFT_TRIGGER: return "Left Trigger"s;
      case SDL_GAMEPAD_AXIS_RIGHT_TRIGGER: return "Right Trigger"s;
      }
      return ""s;
   }

   static uint16_t GetGamepadButton(SDL_GamepadButton button, SDL_GamepadBinding** bindings, int nBindings)
   {
      for (int i = 0; i < nBindings; i++)
      {
         if (bindings[i]->output_type == SDL_GAMEPAD_BINDTYPE_BUTTON && bindings[i]->output.button == button)
         {
            if (bindings[i]->input_type == SDL_GAMEPAD_BINDTYPE_BUTTON)
               return bindings[i]->input.button;
            else if (bindings[i]->input_type == SDL_GAMEPAD_BINDTYPE_HAT)
            {
               switch (bindings[i]->input.hat.hat_mask)
               {
               case SDL_HAT_LEFT: return 0x0100 | static_cast<uint16_t>(bindings[i]->input.hat.hat * 4);
               case SDL_HAT_RIGHT: return 0x0101 | static_cast<uint16_t>(bindings[i]->input.hat.hat * 4);
               case SDL_HAT_UP: return 0x0102 | static_cast<uint16_t>(bindings[i]->input.hat.hat * 4);
               case SDL_HAT_DOWN: return 0x0103 | static_cast<uint16_t>(bindings[i]->input.hat.hat * 4);
               }
            }
         }
      }
      return 0xFFFF;
   }

   static uint16_t GetGamepadAxis(SDL_GamepadAxis axis, SDL_GamepadBinding** bindings, int nBindings)
   {
      for (int i = 0; i < nBindings; i++)
         if (bindings[i]->input_type == SDL_GAMEPAD_BINDTYPE_AXIS && bindings[i]->output_type == SDL_GAMEPAD_BINDTYPE_AXIS && bindings[i]->output.axis.axis == axis)
            return 0x0200 | static_cast<uint16_t>(bindings[i]->input.axis.axis);
      return 0xFFFF;
   }

   void OnJoystickAdded(SDL_JoystickID id)
   {
      auto existing = std::ranges::find_if(m_joysticks, [id](const auto& joy) { return SDL_GetJoystickID(joy.joystick) == id; });
      if (existing != m_joysticks.end())
         return; // Already present (This may happen between initial enumeration and event processing)

      SDL_Joystick* joystick = SDL_OpenJoystick(id);
      if (!joystick)
         return;

      PLOGI << "Joystick connected: " << SDL_GetJoystickName(joystick) << " (ID: " << id << ", Axes: " << SDL_GetNumJoystickAxes(joystick)
            << ", Buttons: " << SDL_GetNumJoystickButtons(joystick) << ", Hats: " << SDL_GetNumJoystickHats(joystick) << ')';

      SDL_Haptic* haptic = nullptr;
      if (SDL_IsJoystickHaptic(joystick))
      {
         haptic = SDL_OpenHapticFromJoystick(joystick);
         if (haptic)
         {
            if (!SDL_InitHapticRumble(haptic))
            {
               ShowError(SDL_GetError());
               SDL_CloseHaptic(haptic);
               haptic = nullptr;
            }
         }
      }
      m_joysticks.emplace_back(joystick, haptic);

      string settingId = GetJoySettingId(joystick);
      string joyName; // Sadly, we do not have a way to easily give a user friendly name when there are multiple devices of the same class, so we use serial number
      if (const char* serial = SDL_GetJoystickSerial(joystick); serial)
      {
         joyName = string(SDL_GetJoystickName(joystick)) + ' ' + serial;
      }
      else
      {
         SDL_GUID guid = SDL_GetJoystickGUID(joystick);
         uint16_t vendor, product, version, crc16;
         SDL_GetJoystickGUIDInfo(guid, &vendor, &product, &version, &crc16);
         if (product)
         {
            std::stringstream ss;
            ss << SDL_GetJoystickName(joystick) << " #" << std::hex << std::setw(4) << std::setfill('0') << product;
            joyName = ss.str();
         }
         else
         {
            joyName = SDL_GetJoystickName(joystick);
         }
      }
      uint16_t deviceId = m_pininput.RegisterDevice(settingId, InputManager::DeviceType::Joystick, joyName);
      m_joystickIds[id] = deviceId;

      // Register all axis to allow selection in the UI (they will eventually be overriden if identified below)
      const int nAxis = SDL_GetNumJoystickAxes(joystick);
      for (int axis = 0; axis < nAxis; axis++)
         m_pininput.RegisterElementName(deviceId, true, 0x0200 | static_cast<uint16_t>(axis), "Axis #" + std::to_string(axis));

      // We are using the gamepad API the opposite of its intent: it is designed to be used when a game expects some standard layout and
      // matches them against the actual joystick. In our case, we don't care about standard layout as we use non standard devices, but
      // we are interested on the button binding for better button naming (if available) and for generic gamepad layout detection
      if (SDL_IsGamepad(id))
      {
         if (SDL_Gamepad* gamepad = SDL_OpenGamepad(id); gamepad)
         {
            int nBindings;
            if (SDL_GamepadBinding** bindings = SDL_GetGamepadBindings(gamepad, &nBindings); bindings)
            {
               for (int i = 0; i < nBindings; i++)
               {
                  if (bindings[i]->input_type == SDL_GAMEPAD_BINDTYPE_BUTTON && bindings[i]->output_type == SDL_GAMEPAD_BINDTYPE_BUTTON)
                  {
                     const string name = GetGamepadButtonName(gamepad, bindings[i]->output.button);
                     if (!name.empty())
                        m_pininput.RegisterElementName(deviceId, false, static_cast<uint16_t>(bindings[i]->input.button), name);
                  }
                  else if (bindings[i]->input_type == SDL_GAMEPAD_BINDTYPE_HAT && bindings[i]->output_type == SDL_GAMEPAD_BINDTYPE_BUTTON)
                  {
                     const string name = GetGamepadButtonName(gamepad, bindings[i]->output.button);
                     if (!name.empty())
                     {
                        switch (bindings[i]->input.hat.hat_mask)
                        {
                        case SDL_HAT_LEFT: m_pininput.RegisterElementName(deviceId, false, 0x0100 | static_cast<uint16_t>(bindings[i]->input.hat.hat * 4), name); break;
                        case SDL_HAT_RIGHT: m_pininput.RegisterElementName(deviceId, false, 0x0101 | static_cast<uint16_t>(bindings[i]->input.hat.hat * 4), name); break;
                        case SDL_HAT_UP: m_pininput.RegisterElementName(deviceId, false, 0x0102 | static_cast<uint16_t>(bindings[i]->input.hat.hat * 4), name); break;
                        case SDL_HAT_DOWN: m_pininput.RegisterElementName(deviceId, false, 0x0103 | static_cast<uint16_t>(bindings[i]->input.hat.hat * 4), name); break;
                        }
                     }
                  }
                  else if (bindings[i]->input_type == SDL_GAMEPAD_BINDTYPE_AXIS && bindings[i]->output_type == SDL_GAMEPAD_BINDTYPE_AXIS)
                  {
                     const string name = GetGamepadAxisName(gamepad, bindings[i]->output.axis.axis);
                     if (!name.empty())
                        m_pininput.RegisterElementName(deviceId, true, 0x0200 | static_cast<uint16_t>(bindings[i]->input.axis.axis), name);
                  }
               }
               
               // Uses these mappings to eventually identify a suitable gamepad layout
               const uint16_t leftTrigger = GetGamepadAxis(SDL_GAMEPAD_AXIS_LEFT_TRIGGER, bindings, nBindings);
               const uint16_t rightTrigger = GetGamepadAxis(SDL_GAMEPAD_AXIS_RIGHT_TRIGGER, bindings, nBindings);
               const uint16_t leftStickX = GetGamepadAxis(SDL_GAMEPAD_AXIS_LEFTX, bindings, nBindings);
               const uint16_t leftStickY = GetGamepadAxis(SDL_GAMEPAD_AXIS_LEFTY, bindings, nBindings);
               const uint16_t rightStickY = GetGamepadAxis(SDL_GAMEPAD_AXIS_RIGHTY, bindings, nBindings);
               const uint16_t leftShoulder = GetGamepadButton(SDL_GAMEPAD_BUTTON_LEFT_SHOULDER, bindings, nBindings);
               const uint16_t rightShoulder = GetGamepadButton(SDL_GAMEPAD_BUTTON_RIGHT_SHOULDER, bindings, nBindings);
               const uint16_t southButton = GetGamepadButton(SDL_GAMEPAD_BUTTON_SOUTH, bindings, nBindings);
               const uint16_t northButton = GetGamepadButton(SDL_GAMEPAD_BUTTON_NORTH, bindings, nBindings);
               const uint16_t eastButton = GetGamepadButton(SDL_GAMEPAD_BUTTON_EAST, bindings, nBindings);
               const uint16_t backButton = GetGamepadButton(SDL_GAMEPAD_BUTTON_BACK, bindings, nBindings);
               const uint16_t startButton = GetGamepadButton(SDL_GAMEPAD_BUTTON_START, bindings, nBindings);
               const uint16_t dpadLeftButton = GetGamepadButton(SDL_GAMEPAD_BUTTON_DPAD_LEFT, bindings, nBindings);
               const uint16_t dpadRightButton = GetGamepadButton(SDL_GAMEPAD_BUTTON_DPAD_RIGHT, bindings, nBindings);
               const uint16_t dpadUpButton = GetGamepadButton(SDL_GAMEPAD_BUTTON_DPAD_UP, bindings, nBindings);
               const uint16_t dpadDownButton = GetGamepadButton(SDL_GAMEPAD_BUTTON_DPAD_DOWN, bindings, nBindings);
            
               // Generic gamepade layout:
               // . Flippers: Left/Right Triggers (axis mapped as buttons with thresholds for flipper/staged flipper)
               // . Magnas: Left/Right Shoulders
               // . Coin: Y (north)
               // . Start: B (east)
               // . Launch Ball: A (south)
               // . Nudge: Left Stick
               // . Plunger: Right Stick
               // . Digital Pad: PinMAME Operator Menu
               // . Exit Interactive: Back
               // . In Game UI: Start
               if (leftTrigger != 0xFFFF && rightTrigger != 0xFFFF && leftShoulder != 0xFFFF && rightShoulder != 0xFFFF && northButton != 0xFFFF && eastButton != 0xFFFF
                  && southButton != 0xFFFF && backButton != 0xFFFF && startButton != 0xFFFF && leftStickX != 0xFFFF && leftStickY != 0xFFFF && rightStickY != 0xFFFF)
               {
                  auto defaultMapping = [this, deviceId,
                     leftTrigger, rightTrigger, leftShoulder, rightShoulder, leftStickX, leftStickY, rightStickY,
                     southButton, northButton, eastButton, backButton, startButton,
                     dpadLeftButton, dpadRightButton, dpadUpButton, dpadDownButton]( //
                     const std::function<bool(const vector<ButtonMapping>&, unsigned int)>& mapButton, //
                     const std::function<bool(const SensorMapping&, SensorMapping::Type type, bool isLinear)>& mapPlunger, //
                     const std::function<bool(const SensorMapping&, const SensorMapping&)>& mapNudge)
                  {
                     bool success = true;
                     success &= mapButton(ButtonMapping::Create(deviceId, leftTrigger, -0.3f), m_pininput.GetLeftFlipperActionId());
                     success &= mapButton(ButtonMapping::Create(deviceId, rightTrigger, -0.3f), m_pininput.GetRightFlipperActionId());
                     success &= mapButton(ButtonMapping::Create(deviceId, leftTrigger, 0.3f), m_pininput.GetStagedLeftFlipperActionId());
                     success &= mapButton(ButtonMapping::Create(deviceId, rightTrigger, 0.3f), m_pininput.GetStagedRightFlipperActionId());
                     success &= mapButton(ButtonMapping::Create(deviceId, leftShoulder), m_pininput.GetLeftMagnaActionId());
                     success &= mapButton(ButtonMapping::Create(deviceId, rightShoulder), m_pininput.GetRightMagnaActionId());
                     success &= mapButton(ButtonMapping::Create(deviceId, northButton), m_pininput.GetAddCreditActionId(0));
                     success &= mapButton(ButtonMapping::Create(deviceId, eastButton), m_pininput.GetStartActionId());
                     success &= mapButton(ButtonMapping::Create(deviceId, southButton), m_pininput.GetLaunchBallActionId());
                     success &= mapButton(ButtonMapping::Create(deviceId, backButton), m_pininput.GetExitInteractiveActionId());
                     // success &= mapButton(ButtonMapping::Create(deviceId, startButton), m_pininput.()); // In Game UI
                     if (dpadLeftButton != 0xFFFF && dpadRightButton != 0xFFFF && dpadUpButton != 0xFFFF && dpadDownButton != 0xFFFF)
                     {
                        success &= mapButton(ButtonMapping::Create(deviceId, dpadLeftButton), m_pininput.GetServiceActionId(0));
                        success &= mapButton(ButtonMapping::Create(deviceId, dpadDownButton), m_pininput.GetServiceActionId(1));
                        success &= mapButton(ButtonMapping::Create(deviceId, dpadUpButton), m_pininput.GetServiceActionId(2));
                        success &= mapButton(ButtonMapping::Create(deviceId, dpadRightButton), m_pininput.GetServiceActionId(3));
                     }
                     success &= mapPlunger(SensorMapping::Create(deviceId, rightStickY, SensorMapping::Type::Position), SensorMapping::Type::Position, true);
                     success &= mapNudge(SensorMapping::Create(deviceId, leftStickX, SensorMapping::Type::Position), SensorMapping::Create(deviceId, leftStickY, SensorMapping::Type::Position));
                     return success;
                  };
                  m_pininput.RegisterDefaultMapping(deviceId, defaultMapping);
               }
               SDL_free(bindings);
            }
            SDL_CloseGamepad(gamepad);
         }
      }

      // We used to detect and auto setup the following hardwares but this has not been readded due to hardware not being
      // available for testing and because the ingame UI allows easy setup:
      // . Microsoft's Sidewinder: date back from 1996, more or less a digital gamepad (see https://en.wikipedia.org/wiki/Microsoft_SideWinder)
      // . UltraCade's UltraPin: date back from 2000 (see https://en.wikipedia.org/wiki/UltraPin)
      // . Pinball Wizard from NanoTech: created around 2008 (see https://www.nanotechgaming.com/pinball-wizard.php)
      // . VirtuaPin: seems to be a KL25z based hardware alike Pinscape controller (see https://virtuapin.net/)

      // mjrnet Pinscape Controller. Obviously not a gamepad, but has defaults plunger / nudge setup layout that we can name and propose
      if (joyName.starts_with("mjrnet Pinscape Controller"s) && nAxis >= 6)
      {
         // We only register the 6 predefined axis. The other ports are all generic and based on user configuration
         // Note: the default mapping we propose only maps the plunger and nudge acceleration, leaving the user to decide if he wants to use velocities as well (with a recent enough firmware)
         m_pininput.RegisterElementName(deviceId, true, 0x0200, "Nudge X Acceleration"s);
         m_pininput.RegisterElementName(deviceId, true, 0x0201, "Nudge Y Acceleration"s);
         m_pininput.RegisterElementName(deviceId, true, 0x0202, "Plunger Position"s);
         m_pininput.RegisterElementName(deviceId, true, 0x0203, "Nudge X Velocity"s);
         m_pininput.RegisterElementName(deviceId, true, 0x0204, "Nudge Y Velocity"s);
         m_pininput.RegisterElementName(deviceId, true, 0x0205, "Plunger Velocity"s);
         auto defaultMapping = [this, deviceId]( //
            const std::function<bool(const vector<ButtonMapping>&, unsigned int)>& mapButton, //
            const std::function<bool(const SensorMapping&, SensorMapping::Type type, bool isLinear)>& mapPlunger, //
            const std::function<bool(const SensorMapping&, const SensorMapping&)>& mapNudge)
         {
            bool success = true;
            success &= mapNudge(SensorMapping::Create(deviceId, 0x0200, SensorMapping::Type::Acceleration), SensorMapping::Create(deviceId, 0x0201, SensorMapping::Type::Acceleration));
            success &= mapPlunger(SensorMapping::Create(deviceId, 0x0202, SensorMapping::Type::Position), SensorMapping::Type::Position, true);
            return success;
         };
         m_pininput.RegisterDefaultMapping(deviceId, defaultMapping);
      }
   }

   void OnJoystickRemoved(SDL_JoystickID id)
   {
      const SDL_Joystick* const joystick = SDL_GetJoystickFromID(id);
      if (joystick == nullptr)
         return;

      auto it = std::ranges::find_if(m_joysticks, [joystick](const auto& joy) { return joy.joystick == joystick; });
      assert(it != m_joysticks.end());
      if (it->haptic)
         SDL_CloseHaptic(it->haptic);
      SDL_CloseJoystick(it->joystick);
      m_joysticks.erase(it);

      uint16_t deviceId = m_joystickIds[id];
      m_pininput.UnregisterDevice(deviceId);
      m_joystickIds.erase(id);
   }

   InputManager& m_pininput;
   struct JoyDef
   {
      SDL_Joystick* joystick;
      SDL_Haptic* haptic;
   };
   vector<JoyDef> m_joysticks;
   ankerl::unordered_dense::map<SDL_JoystickID, uint16_t> m_joystickIds;
};
