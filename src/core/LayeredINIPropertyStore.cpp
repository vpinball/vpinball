// license:GPLv3+

#pragma once

#include "core/stdafx.h"
#include "LayeredINIPropertyStore.h"

#include "utils/fileio.h"

namespace VPX::Properties
{

LayeredINIPropertyStore::LayeredINIPropertyStore(PropertyRegistry& registry)
   : PropertyStore(registry)
   , m_parent(std::nullopt)
{
}

LayeredINIPropertyStore::LayeredINIPropertyStore(LayeredINIPropertyStore& parent)
   : PropertyStore(parent.m_registry)
   , m_parent(parent)
{
   // We do not support double level overrides (in fact, we do, but this does not make sense, so just abort)
   assert(!parent.m_parent.has_value());
}


bool LayeredINIPropertyStore::Load(const string& path)
{
   m_path = path;
   m_modified = false;
   m_intValues.clear();
   m_floatValues.clear();
   m_stringValues.clear();
   mINI::INIFile file(path);
   if (file.read(m_ini))
   {
      PLOGI << "Settings file was loaded from '" << path << '\'';
      for (PropertyRegistry::PropId id : m_registry.get().GetPropertyIds())
         LoadFromINI(id);
      return true;
   }
   else
   {
      return false;
   }
}

void LayeredINIPropertyStore::Load(const mINI::INIStructure& ini)
{
   m_modified = false;
   m_intValues.clear();
   m_floatValues.clear();
   m_stringValues.clear();
   m_ini = ini;
   for (PropertyRegistry::PropId id : m_registry.get().GetPropertyIds())
      LoadFromINI(id);
}

bool LayeredINIPropertyStore::LoadFromINI(PropertyRegistry::PropId id)
{
   const PropertyDef* prop = m_registry.get().GetProperty(id);
   if (!m_ini.has(prop->m_groupId) || !m_ini[prop->m_groupId].has(prop->m_propId))
      return false;
   const string value = m_ini[prop->m_groupId][prop->m_propId];
   switch (prop->m_type)
   {
   case PropertyDef::Type::Float:
      if (float floatValue; try_parse_float(value, floatValue))
         Set(id, floatValue);
      else
         return false;
      break;

   case PropertyDef::Type::Int:
      if (int intValue; try_parse_int(value, intValue))
         Set(id, intValue);
      else
         return false;
      break;

   case PropertyDef::Type::Bool:
      if (int intValue; try_parse_int(value, intValue))
         Set(id, intValue != 0 ? 1 : 0);
      else if (StrCompareNoCase(value, "true") || StrCompareNoCase(value, "on") || StrCompareNoCase(value, "enable"))
         Set(id, 1);
      else if (StrCompareNoCase(value, "false") || StrCompareNoCase(value, "off") || StrCompareNoCase(value, "disable"))
         Set(id, 0);
      else
         return false;
      break;

   case PropertyDef::Type::Enum:
   {
      auto enumProp = dynamic_cast<const EnumPropertyDef*>(prop);
      if (const int intValue = enumProp->ParseEnum(value); enumProp->IsValid(intValue))
         Set(id, intValue);
      else
         return false;
      break;
   }

   case PropertyDef::Type::String:
      Set(id, value);
      break;

   default: assert(false); break;
   }
   return true;
}

void LayeredINIPropertyStore::Save()
{
   if (m_parent)
      m_parent->get().Save();
   if (!m_modified)
      return;

   // Update INI map
   // Update autogenerated comments for registered properties ? this would need to move away from mINI which only supports lazy writing (preserving comments, not generating them)
   // Implement saving bool and enum as literals ? This would make the INI file more readable but break backward compatibility
   UpdateLiveStore();
   PropertyRegistry::PropId id;
   id = { PropertyRegistry::StoreType::Int, 0 };
   for (id.index = 0; id.index < m_intValues.size(); id.index++)
   {
      const auto& prop = m_registry.get().GetProperty(id);
      if (m_parent && (!m_intValues[id.index].defined || m_intValues[id.index].value == m_parent->get().GetInt(id)))
         m_ini[prop->m_groupId].remove(prop->m_propId);
      else if (m_intValues[id.index].defined)
         m_ini[prop->m_groupId][prop->m_propId] = std::to_string(m_intValues[id.index].value);
      else
         m_ini[prop->m_groupId][prop->m_propId] = ""s;
   }
   id = { PropertyRegistry::StoreType::Float, 0 };
   for (id.index = 0; id.index < m_floatValues.size(); id.index++)
   {
      const auto& prop = m_registry.get().GetProperty(id);
      if (m_parent && (!m_floatValues[id.index].defined || m_floatValues[id.index].value == m_parent->get().GetFloat(id)))
         m_ini[prop->m_groupId].remove(prop->m_propId);
      else if (m_floatValues[id.index].defined)
         m_ini[prop->m_groupId][prop->m_propId] = f2sz(m_floatValues[id.index].value);
      else
         m_ini[prop->m_groupId][prop->m_propId] = ""s;
   }
   id = { PropertyRegistry::StoreType::String, 0 };
   for (id.index = 0; id.index < m_stringValues.size(); id.index++)
   {
      const auto& prop = m_registry.get().GetProperty(id);
      if (m_parent && (!m_stringValues[id.index].defined || m_stringValues[id.index].value == m_parent->get().GetString(id)))
         m_ini[prop->m_groupId].remove(prop->m_propId);
      else if (m_stringValues[id.index].defined)
         m_ini[prop->m_groupId][prop->m_propId] = m_stringValues[id.index].value;
      else
         m_ini[prop->m_groupId][prop->m_propId] = ""s;
   }

   // Save to file
   size_t size = 0;
   for (const auto& [key, value] : m_ini)
      size += value.size();
   if (size > 0)
   {
      mINI::INIFile file(m_path);
      file.write(m_ini, true);
   }
   else if (FileExists(m_path))
   {
      // Remove if empty
      remove(m_path.c_str());
   }
   m_modified = false;
}

void LayeredINIPropertyStore::GenerateTemplate(const string& path) const
{
   std::ofstream file(path);
   if (!file.is_open())
      return;

   file << "; #######################################################\n";
   file << "; #  Visual Pinball X settings file\n";
   file << "; #\n";
   file << "; # This file holds all visual pinball settings.\n";
   file << "; # If you need to reset all settings to their default,\n";
   file << "; # just delete this file and it will be recreated on\n";
   file << "; # next application start.\n";
   file << "; #\n";
   file << "; # When a property is not defined (nothing after the\n";
   file << "; # equal '=' sign), VPX will use a default value for it.\n";
   file << "; #\n";
   file << "; #######################################################\n";

   vector<string> groups;
   for (auto propId : m_registry.get().GetPropertyIds())
      if (const string group = m_registry.get().GetProperty(propId)->m_groupId; FindIndexOf(groups, group) == -1)
         groups.push_back(group);

   for (const string& group : groups)
   {
      file << "\n";
      file << "\n";
      file << "[" << group << "]\n";
      for (auto propId : m_registry.get().GetPropertyIds())
      {
         const PropertyDef* prop = m_registry.get().GetProperty(propId);
         if (prop->m_groupId == group)
         {
            file << "; " << prop->m_label;
            if (prop->m_description.find('\n') == std::string::npos)
               file << ": " << prop->m_description;
            switch (prop->m_type)
            {
            case PropertyDef::Type::Float:
               file << " [Default: " << f2sz(dynamic_cast<const FloatPropertyDef*>(prop)->m_def, false) << " in " << f2sz(dynamic_cast<const FloatPropertyDef*>(prop)->m_min, false) << " .. "
                    << f2sz(dynamic_cast<const FloatPropertyDef*>(prop)->m_max, false) << ']';
               break;
            case PropertyDef::Type::Int:
               file << " [Default: " << std::to_string(dynamic_cast<const IntPropertyDef*>(prop)->m_def) << " in " << std::to_string(dynamic_cast<const IntPropertyDef*>(prop)->m_min)
                    << " .. " << std::to_string(dynamic_cast<const IntPropertyDef*>(prop)->m_max) << ']';
               break;
            case PropertyDef::Type::Bool: file << " [Default: " << (dynamic_cast<const BoolPropertyDef*>(prop)->m_def ? '1' : '0') << ']'; break;
            case PropertyDef::Type::Enum:
            {
               auto enumProp = dynamic_cast<const EnumPropertyDef*>(prop);
               file << " [Default: '" << enumProp->m_values[enumProp->m_def] << "'";
               for (size_t i = 0; i < enumProp->m_values.size(); i++)
                  file << ", " << i << "='" << enumProp->m_values[i] << "'";
               file << ']';
               break;
            }
            case PropertyDef::Type::String: file << " [Default: '" << dynamic_cast<const StringPropertyDef*>(prop)->m_def << "']"; break;
            }
            if (prop->m_description.find('\n') != std::string::npos)
            {
               std::string token;
               std::istringstream tokenStream(prop->m_description);
               file << ":\n";
               while (std::getline(tokenStream, token, '\n'))
                  file << ";   " << token;
            }
            file << '\n' << prop->m_propId << " =\n\n";
         }
      }
   }

   file.close();
}

void LayeredINIPropertyStore::UpdateLiveStore()
{
   for (PropertyRegistry::PropId propId : m_registry.get().GetPropertyIds())
   {
      switch (propId.type)
      {
      case PropertyRegistry::StoreType::Int:
         if (propId.index >= static_cast<int>(m_intValues.size()))
         {
            assert(propId.index == static_cast<int>(m_intValues.size())); // We expect property indices to be consecutive
            m_intValues.emplace_back(false, 0);
            LoadFromINI(propId); // Reparse the raw INI, as the property may have been registered after last parse
         }
         break;
      case PropertyRegistry::StoreType::Float:
         if (propId.index >= static_cast<int>(m_floatValues.size()))
         {
            assert(propId.index == static_cast<int>(m_floatValues.size())); // We expect property indices to be consecutive
            m_floatValues.emplace_back(false, 0.f);
            LoadFromINI(propId); // Reparse the raw INI, as the property may have been registered after last parse
         }
         break;
      case PropertyRegistry::StoreType::String:
         if (propId.index >= static_cast<int>(m_stringValues.size()))
         {
            assert(propId.index == static_cast<int>(m_stringValues.size())); // We expect property indices to be consecutive
            m_stringValues.emplace_back(false, ""s);
            LoadFromINI(propId); // Reparse the raw INI, as the property may have been registered after last parse
         }
         break;
      default: assert(false); break;
      }
   }
}

void LayeredINIPropertyStore::Reset(PropertyRegistry::PropId propId)
{
   switch (propId.type)
   {
   case PropertyRegistry::StoreType::Int:
   {
      auto& value = GetIntValue(propId);
      m_modified |= value.defined;
      value.defined = false;
      break;
   }
   case PropertyRegistry::StoreType::Float:
   {
      auto& value = GetFloatValue(propId);
      m_modified |= value.defined;
      value.defined = false;
      break;
   }
   case PropertyRegistry::StoreType::String:
   {
      auto& value = GetStringValue(propId);
      m_modified |= value.defined;
      value.defined = false;
      break;
   }
   default: assert(false); break;
   }
}

LayeredINIPropertyStore::IntValue& LayeredINIPropertyStore::GetIntValue(PropertyRegistry::PropId propId)
{
   if (propId.index >= m_intValues.size())
      UpdateLiveStore();
   return m_intValues[propId.index];
}

int LayeredINIPropertyStore::GetDefaultInt(PropertyRegistry::PropId propId) const
{
   if (m_parent)
      return m_parent->get().GetInt(propId);
   const PropertyDef* prop = m_registry.get().GetProperty(propId);
   switch (prop->m_type)
   {
   case PropertyDef::Type::Int: return dynamic_cast<const IntPropertyDef*>(prop)->m_def;
   case PropertyDef::Type::Enum: return dynamic_cast<const EnumPropertyDef*>(prop)->m_def;
   case PropertyDef::Type::Bool: return dynamic_cast<const BoolPropertyDef*>(prop)->m_def ? 1 : 0;
   default: assert(false); return 0;
   }
}

int LayeredINIPropertyStore::GetInt(PropertyRegistry::PropId propId) const
{
   assert(propId.type == PropertyRegistry::StoreType::Int);
   const auto& intValue = const_cast<LayeredINIPropertyStore*>(this)->GetIntValue(propId);
   return intValue.defined ? intValue.value : GetDefaultInt(propId);
}

void LayeredINIPropertyStore::Set(PropertyRegistry::PropId propId, int value)
{
   assert(propId.type == PropertyRegistry::StoreType::Int);
   auto& intValue = GetIntValue(propId);
   m_modified |= !intValue.defined || (intValue.value != value);
   intValue.defined = true;
   intValue.value = value;
}


LayeredINIPropertyStore::FloatValue& LayeredINIPropertyStore::GetFloatValue(PropertyRegistry::PropId propId)
{
   if (propId.index >= m_floatValues.size())
      UpdateLiveStore();
   return m_floatValues[propId.index];
}

float LayeredINIPropertyStore::GetDefaultFloat(PropertyRegistry::PropId propId) const
{
   if (m_parent)
      return m_parent->get().GetFloat(propId);
   const PropertyDef* prop = m_registry.get().GetProperty(propId);
   assert(prop->m_type == PropertyDef::Type::Float);
   return dynamic_cast<const FloatPropertyDef*>(prop)->m_def;
}

float LayeredINIPropertyStore::GetFloat(PropertyRegistry::PropId propId) const
{
   assert(propId.type == PropertyRegistry::StoreType::Float);
   const auto& floatValue = const_cast<LayeredINIPropertyStore*>(this)->GetFloatValue(propId);
   return floatValue.defined ? floatValue.value : GetDefaultFloat(propId);
}

void LayeredINIPropertyStore::Set(PropertyRegistry::PropId propId, float value)
{
   assert(propId.type == PropertyRegistry::StoreType::Float);
   auto& floatValue = GetFloatValue(propId);
   m_modified |= !floatValue.defined || (floatValue.value != value);
   floatValue.defined = true;
   floatValue.value = value;
}


LayeredINIPropertyStore::StringValue& LayeredINIPropertyStore::GetStringValue(PropertyRegistry::PropId propId)
{
   if (propId.index >= m_stringValues.size())
      UpdateLiveStore();
   return m_stringValues[propId.index];
}

const string& LayeredINIPropertyStore::GetDefaultString(PropertyRegistry::PropId propId) const
{
   if (m_parent)
      return m_parent->get().GetString(propId);
   const PropertyDef* prop = m_registry.get().GetProperty(propId);
   assert(prop->m_type == PropertyDef::Type::String);
   return dynamic_cast<const StringPropertyDef*>(prop)->m_def;
}

const string& LayeredINIPropertyStore::GetString(PropertyRegistry::PropId propId) const
{
   assert(propId.type == PropertyRegistry::StoreType::String);
   const auto& stringValue = const_cast<LayeredINIPropertyStore*>(this)->GetStringValue(propId);
   return stringValue.defined ? stringValue.value : GetDefaultString(propId);
}

void LayeredINIPropertyStore::Set(PropertyRegistry::PropId propId, const string& value)
{
   assert(propId.type == PropertyRegistry::StoreType::String);
   auto& stringValue = GetStringValue(propId);
   m_modified |= !stringValue.defined || (stringValue.value != value);
   stringValue.defined = true;
   stringValue.value = value;
}

};