// license:GPLv3+

#include "core/stdafx.h"
#include "LayeredINIPropertyStore.h"

#include "utils/fileio.h"

namespace VPX::Properties
{

LayeredINIPropertyStore::LayeredINIPropertyStore(PropertyRegistry& registry)
   : PropertyStore(registry)
   , m_parent(std::nullopt)
{
}

LayeredINIPropertyStore::LayeredINIPropertyStore(LayeredINIPropertyStore& parent)
   : PropertyStore(parent.m_registry)
   , m_parent(parent)
{
   // We do not support double level overrides (in fact, we do, but this does not make sense, so just abort)
   assert(!parent.m_parent.has_value());
}

void LayeredINIPropertyStore::Reset()
{
   m_modified = false;
   m_intValues.clear();
   m_floatValues.clear();
   m_stringValues.clear();
   m_ini.clear();
}

bool LayeredINIPropertyStore::Load()
{
   Reset();
   mINI::INIFile file(m_path);
   if (file.read(m_ini))
   {
      for (PropertyRegistry::PropId id : m_registry.get().GetPropertyIds())
         LoadFromINI(id);
      return true;
   }
   else
   {
      return false;
   }
}

void LayeredINIPropertyStore::Load(const mINI::INIStructure& ini)
{
   m_modified = false;
   m_intValues.clear();
   m_floatValues.clear();
   m_stringValues.clear();
   m_ini = ini;
   for (PropertyRegistry::PropId id : m_registry.get().GetPropertyIds())
      LoadFromINI(id);
}

void LayeredINIPropertyStore::Load(const LayeredINIPropertyStore& store)
{
   m_modified = store.m_modified;
   m_intValues = store.m_intValues;
   m_floatValues = store.m_floatValues;
   m_stringValues = store.m_stringValues;
   m_ini = store.m_ini;
}

bool LayeredINIPropertyStore::LoadFromINI(PropertyRegistry::PropId id)
{
   const PropertyDef* prop = m_registry.get().GetProperty(id);
   if (!m_ini.has(prop->m_groupId) || !m_ini[prop->m_groupId].has(prop->m_propId))
      return false;
   const string value = m_ini[prop->m_groupId][prop->m_propId];
   switch (prop->m_type)
   {
   case PropertyDef::Type::Float:
      if (float floatValue; try_parse_float(value, floatValue))
         Set(id, floatValue);
      else
         return false;
      break;

   case PropertyDef::Type::Int:
      if (int intValue; try_parse_int(value, intValue))
         Set(id, intValue);
      else
         return false;
      break;

   case PropertyDef::Type::Bool:
      if (int intValue; try_parse_int(value, intValue))
         Set(id, intValue != 0 ? 1 : 0);
      else if (StrCompareNoCase(value, "true"s) || StrCompareNoCase(value, "on"s) || StrCompareNoCase(value, "enable"s))
         Set(id, 1);
      else if (StrCompareNoCase(value, "false"s) || StrCompareNoCase(value, "off"s) || StrCompareNoCase(value, "disable"s))
         Set(id, 0);
      else
         return false;
      break;

   case PropertyDef::Type::Enum:
   {
      auto enumProp = dynamic_cast<const EnumPropertyDef*>(prop);
      if (const int intValue = enumProp->ParseEnum(value); enumProp->IsValid(intValue))
         Set(id, intValue);
      else
         return false;
      break;
   }

   case PropertyDef::Type::String:
      if (value.empty()) // INI file does not gives us a way to know if the value is undefined or set to empty string, so we consider empty string as undefined
         Reset(id);
      else
         Set(id, value);
      break;

   default: assert(false); break;
   }
   return true;
}

void LayeredINIPropertyStore::Save()
{
   if (m_parent)
      m_parent->get().Save();
   if (!m_modified)
      return;

   // Update INI map
   // Update autogenerated comments for registered properties ? this would need to move away from mINI which only supports lazy writing (preserving comments, not generating them)
   // Implement saving bool and enum as literals ? This would make the INI file more readable but break backward compatibility
   UpdateLiveStore();
   PropertyRegistry::PropId id;
   id = { PropertyRegistry::StoreType::Int, 0 };
   for (id.index = 0; id.index < m_intValues.size(); id.index++)
   {
      const auto& prop = m_registry.get().GetProperty(id);
      if (m_intValues[id.index].defined)
      {
         if (m_parent && !prop->m_contextualProperty && m_intValues[id.index].value == m_parent->get().GetInt(id))
            m_ini[prop->m_groupId].remove(prop->m_propId);
         else
            m_ini[prop->m_groupId][prop->m_propId] = std::to_string(m_intValues[id.index].value);
      }
      else
      {
         if (m_parent)
            m_ini[prop->m_groupId].remove(prop->m_propId);
         else
            m_ini[prop->m_groupId][prop->m_propId].clear();
      }
   }
   id = { PropertyRegistry::StoreType::Float, 0 };
   for (id.index = 0; id.index < m_floatValues.size(); id.index++)
   {
      const auto& prop = m_registry.get().GetProperty(id);
      if (m_floatValues[id.index].defined)
      {
         if (m_parent && !prop->m_contextualProperty && m_floatValues[id.index].value == m_parent->get().GetFloat(id))
            m_ini[prop->m_groupId].remove(prop->m_propId);
         else
            m_ini[prop->m_groupId][prop->m_propId] = f2sz(m_floatValues[id.index].value, false);
      }
      else
      {
         if (m_parent)
            m_ini[prop->m_groupId].remove(prop->m_propId);
         else
            m_ini[prop->m_groupId][prop->m_propId].clear();
      }
   }
   id = { PropertyRegistry::StoreType::String, 0 };
   for (id.index = 0; id.index < m_stringValues.size(); id.index++)
   {
      const auto& prop = m_registry.get().GetProperty(id);
      if (m_stringValues[id.index].defined)
      {
         if (m_parent && !prop->m_contextualProperty && m_stringValues[id.index].value == m_parent->get().GetString(id))
            m_ini[prop->m_groupId].remove(prop->m_propId);
         else
            m_ini[prop->m_groupId][prop->m_propId] = m_stringValues[id.index].value;
      }
      else
      {
         if (m_parent)
            m_ini[prop->m_groupId].remove(prop->m_propId);
         else
            m_ini[prop->m_groupId][prop->m_propId].clear();
      }
   }

   // Remove empty sections
   bool changed = true;
   while (changed)
   {
      changed = false;
      for (auto& [k, v] : m_ini)
         if (v.empty())
         {
            changed = true;
            m_ini.remove(k);
            break;
         }
   }

   // Save to file
   size_t size = 0;
   for (const auto& [key, value] : m_ini)
      size += value.size();
   if (size > 0)
   {
      mINI::INIFile file(m_path);
      if (!file.write(m_ini, true))
      {
         PLOGE << "Failed to save settings file to '" << m_path << '\'';
      }
   }
   else if (FileExists(m_path))
   {
      // Remove if empty
      remove(m_path.c_str());
   }
   m_modified = false;
}

void LayeredINIPropertyStore::GenerateTemplate(const string& path) const
{
   std::ofstream file(path);
   if (!file.is_open())
      return;

   file << "; #######################################################\n";
   file << "; #  Visual Pinball X settings file\n";
   file << "; #\n";
   file << "; # This file holds all Visual Pinball settings.\n";
   file << "; # If you want to reset all settings to their default,\n";
   file << "; # just delete this file and it will be recreated on the\n";
   file << "; # next application start.\n";
   file << "; #\n";
   file << "; # When a property is not defined (nothing after the\n";
   file << "; # equal '=' sign), VPX will use the default value for it.\n";
   file << "; # (can be used to reset single properties)\n";
   file << "; #\n";
   file << "; #######################################################\n";

   vector<string> groups;
   for (auto propId : m_registry.get().GetPropertyIds())
      if (const string group = m_registry.get().GetProperty(propId)->m_groupId; FindIndexOf(groups, group) == -1)
         groups.push_back(group);

   auto toHex = [](int rgba) -> string
   {
      std::stringstream stream;
      stream << std::setfill('0') << std::setw(8) << std::hex << rgba;
      return stream.str();
   };

   for (const string& group : groups)
   {
      file << '\n';
      file << '\n';
      file << '[' << group << "]\n";
      for (auto propId : m_registry.get().GetPropertyIds())
      {
         const PropertyDef* prop = m_registry.get().GetProperty(propId);
         if (prop->m_groupId == group)
         {
            file << "; ";
            if (!prop->m_label.empty())
               file << prop->m_label << ": ";
            if (!prop->m_description.empty() && prop->m_description.find('\n') == std::string::npos)
               file << prop->m_description;
            switch (prop->m_type)
            {
            case PropertyDef::Type::Float:
               file << " [Default: " << f2sz(dynamic_cast<const FloatPropertyDef*>(prop)->m_def, false);
               if (dynamic_cast<const FloatPropertyDef*>(prop)->m_min != FLT_MIN && dynamic_cast<const FloatPropertyDef*>(prop)->m_max != FLT_MAX)
                  file << " in " << f2sz(dynamic_cast<const FloatPropertyDef*>(prop)->m_min, false) << " .. " << f2sz(dynamic_cast<const FloatPropertyDef*>(prop)->m_max, false);
               if (dynamic_cast<const FloatPropertyDef*>(prop)->m_step != 0.f)
                  file << " by " << f2sz(dynamic_cast<const FloatPropertyDef*>(prop)->m_step, false) << " steps";
               file << ']';
               break;

            case PropertyDef::Type::Int:
            {
               if (dynamic_cast<const IntPropertyDef*>(prop)->m_max == 0xFFFFFF)
               {
                  file << " [Default: 0x" << toHex(dynamic_cast<const IntPropertyDef*>(prop)->m_def);
                  if (dynamic_cast<const IntPropertyDef*>(prop)->m_min != INT_MIN && dynamic_cast<const IntPropertyDef*>(prop)->m_max != INT_MAX)
                     file << " in 0x" << toHex(dynamic_cast<const IntPropertyDef*>(prop)->m_min) << " .. 0x" << toHex(dynamic_cast<const IntPropertyDef*>(prop)->m_max);
                  file << ']';
               }
               else
               {
                  file << " [Default: " << std::to_string(dynamic_cast<const IntPropertyDef*>(prop)->m_def);
                  if (dynamic_cast<const IntPropertyDef*>(prop)->m_min != INT_MIN && dynamic_cast<const IntPropertyDef*>(prop)->m_max != INT_MAX)
                     file << " in " << std::to_string(dynamic_cast<const IntPropertyDef*>(prop)->m_min) << " .. " << std::to_string(dynamic_cast<const IntPropertyDef*>(prop)->m_max);
                  file << ']';
               }
            }
               break;

            case PropertyDef::Type::Bool:
               file << " [Default: " << (dynamic_cast<const BoolPropertyDef*>(prop)->m_def ? '1' : '0') << ']';
               break;

            case PropertyDef::Type::Enum:
            {
               auto enumProp = dynamic_cast<const EnumPropertyDef*>(prop);
               file << " [Default: '" << enumProp->m_values[enumProp->m_def - enumProp->m_min] << '\'';
               for (size_t i = 0; i < enumProp->m_values.size(); i++)
                  file << ", " << (enumProp->m_min + static_cast<int>(i)) << "='" << enumProp->m_values[i] << '\'';
               file << ']';
               break;
            }
            case PropertyDef::Type::String:
               file << " [Default: '" << dynamic_cast<const StringPropertyDef*>(prop)->m_def << "']";
               break;
            }
            if (!prop->m_description.empty() && prop->m_description.find('\n') != std::string::npos)
            {
               std::string token;
               std::istringstream tokenStream(prop->m_description);
               file << ":\n";
               while (std::getline(tokenStream, token, '\n'))
                  file << ";   " << token << '\n';
            }
            else
               file << '\n';
            file << prop->m_propId << " = \n\n";
         }
      }
   }

   file.close();
}

void LayeredINIPropertyStore::UpdateLiveStore()
{
   for (PropertyRegistry::PropId propId : m_registry.get().GetPropertyIds())
   {
      switch (propId.type)
      {
      case PropertyRegistry::StoreType::Int:
         if (propId.index >= static_cast<int>(m_intValues.size()))
         {
            assert(propId.index == static_cast<int>(m_intValues.size())); // We expect property indices to be consecutive
            m_intValues.emplace_back(false, 0);
            LoadFromINI(propId); // Reparse the raw INI, as the property may have been registered after last parse
         }
         break;
      case PropertyRegistry::StoreType::Float:
         if (propId.index >= static_cast<int>(m_floatValues.size()))
         {
            assert(propId.index == static_cast<int>(m_floatValues.size())); // We expect property indices to be consecutive
            m_floatValues.emplace_back(false, 0.f);
            LoadFromINI(propId); // Reparse the raw INI, as the property may have been registered after last parse
         }
         break;
      case PropertyRegistry::StoreType::String:
         if (propId.index >= static_cast<int>(m_stringValues.size()))
         {
            assert(propId.index == static_cast<int>(m_stringValues.size())); // We expect property indices to be consecutive
            m_stringValues.emplace_back(false, ""s);
            LoadFromINI(propId); // Reparse the raw INI, as the property may have been registered after last parse
         }
         break;
      default: assert(false); break;
      }
   }
}

void LayeredINIPropertyStore::Reset(PropertyRegistry::PropId propId)
{
   switch (propId.type)
   {
   case PropertyRegistry::StoreType::Int:
   {
      auto& value = GetIntValue(propId);
      m_modified |= value.defined;
      value.defined = false;
      break;
   }
   case PropertyRegistry::StoreType::Float:
   {
      auto& value = GetFloatValue(propId);
      m_modified |= value.defined;
      value.defined = false;
      break;
   }
   case PropertyRegistry::StoreType::String:
   {
      auto& value = GetStringValue(propId);
      m_modified |= value.defined;
      value.defined = false;
      break;
   }
   default: assert(false); break;
   }
}

LayeredINIPropertyStore::IntValue& LayeredINIPropertyStore::GetIntValue(PropertyRegistry::PropId propId)
{
   if (propId.index >= m_intValues.size())
      UpdateLiveStore();
   return m_intValues[propId.index];
}

int LayeredINIPropertyStore::GetDefaultInt(PropertyRegistry::PropId propId) const
{
   if (m_parent)
      return m_parent->get().GetInt(propId);
   const PropertyDef* prop = m_registry.get().GetProperty(propId);
   switch (prop->m_type)
   {
   case PropertyDef::Type::Int: return dynamic_cast<const IntPropertyDef*>(prop)->m_def;
   case PropertyDef::Type::Enum: return dynamic_cast<const EnumPropertyDef*>(prop)->m_def;
   case PropertyDef::Type::Bool: return dynamic_cast<const BoolPropertyDef*>(prop)->m_def ? 1 : 0;
   default: assert(false); return 0;
   }
}

int LayeredINIPropertyStore::GetInt(PropertyRegistry::PropId propId) const
{
   assert(propId.type == PropertyRegistry::StoreType::Int);
   const auto& intValue = const_cast<LayeredINIPropertyStore*>(this)->GetIntValue(propId);
   return intValue.defined ? intValue.value : GetDefaultInt(propId);
}

void LayeredINIPropertyStore::Set(PropertyRegistry::PropId propId, int value)
{
   assert(propId.type == PropertyRegistry::StoreType::Int);
   auto& intValue = GetIntValue(propId);
   m_modified |= !intValue.defined || (intValue.value != value);
   intValue.defined = true;
   intValue.value = value;
}


LayeredINIPropertyStore::FloatValue& LayeredINIPropertyStore::GetFloatValue(PropertyRegistry::PropId propId)
{
   if (propId.index >= m_floatValues.size())
      UpdateLiveStore();
   return m_floatValues[propId.index];
}

float LayeredINIPropertyStore::GetDefaultFloat(PropertyRegistry::PropId propId) const
{
   if (m_parent)
      return m_parent->get().GetFloat(propId);
   const PropertyDef* prop = m_registry.get().GetProperty(propId);
   assert(prop->m_type == PropertyDef::Type::Float);
   return dynamic_cast<const FloatPropertyDef*>(prop)->m_def;
}

float LayeredINIPropertyStore::GetFloat(PropertyRegistry::PropId propId) const
{
   assert(propId.type == PropertyRegistry::StoreType::Float);
   const auto& floatValue = const_cast<LayeredINIPropertyStore*>(this)->GetFloatValue(propId);
   return floatValue.defined ? floatValue.value : GetDefaultFloat(propId);
}

void LayeredINIPropertyStore::Set(PropertyRegistry::PropId propId, float value)
{
   assert(propId.type == PropertyRegistry::StoreType::Float);
   auto& floatValue = GetFloatValue(propId);
   m_modified |= !floatValue.defined || (floatValue.value != value);
   floatValue.defined = true;
   floatValue.value = value;
}


LayeredINIPropertyStore::StringValue& LayeredINIPropertyStore::GetStringValue(PropertyRegistry::PropId propId)
{
   if (propId.index >= m_stringValues.size())
      UpdateLiveStore();
   return m_stringValues[propId.index];
}

const string& LayeredINIPropertyStore::GetDefaultString(PropertyRegistry::PropId propId) const
{
   if (m_parent)
      return m_parent->get().GetString(propId);
   const PropertyDef* prop = m_registry.get().GetProperty(propId);
   assert(prop->m_type == PropertyDef::Type::String);
   return dynamic_cast<const StringPropertyDef*>(prop)->m_def;
}

const string& LayeredINIPropertyStore::GetString(PropertyRegistry::PropId propId) const
{
   assert(propId.type == PropertyRegistry::StoreType::String);
   const auto& stringValue = const_cast<LayeredINIPropertyStore*>(this)->GetStringValue(propId);
   return stringValue.defined ? stringValue.value : GetDefaultString(propId);
}

void LayeredINIPropertyStore::Set(PropertyRegistry::PropId propId, const string& value)
{
   assert(propId.type == PropertyRegistry::StoreType::String);
   auto& stringValue = GetStringValue(propId);
   m_modified |= !stringValue.defined || (stringValue.value != value);
   stringValue.defined = true;
   stringValue.value = value;
}

}
